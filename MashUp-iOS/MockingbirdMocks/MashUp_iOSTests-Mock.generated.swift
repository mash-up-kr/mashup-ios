//
//  MashUp_iOSTests-Mock.generated.swift
//  MashUp_iOS
//
//  Generated by Mockingbird v0.20.0.
//  DO NOT EDIT
//

@testable import MashUp_iOS
@testable import Mockingbird
import AVFoundation
import Foundation
import Moya
import ReactorKit
import RxCocoa
import RxDataSources
import RxMoya
import RxRelay
import RxSwift
import SnapKit
import Swift
import Then
import UIKit

private let mkbGenericStaticMockContext = Mockingbird.GenericStaticMockContext()

// MARK: - Mocked AttendanceService
public final class AttendanceServiceMock: MashUp_iOS.AttendanceService, Mockingbird.Mock {
  typealias MockingbirdSupertype = MashUp_iOS.AttendanceService
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "MashUp_iOS"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    AttendanceServiceMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `attend`(withCode `code`: MashUp_iOS.Code)
  public func `attend`(withCode `code`: MashUp_iOS.Code) -> Observable<Bool> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`attend`(withCode `code`: MashUp_iOS.Code) -> Observable<Bool>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`code`)], returnType: Swift.ObjectIdentifier((Observable<Bool>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (MashUp_iOS.Code) -> Observable<Bool> { return mkbImpl(`code`) }
      if let mkbImpl = mkbImpl as? () -> Observable<Bool> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Observable<Bool> = mkbObject.`attend`(withCode: `code`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Observable<Bool>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `attend`(withCode `code`: @autoclosure () -> MashUp_iOS.Code) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (MashUp_iOS.Code) -> Observable<Bool>, Observable<Bool>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (MashUp_iOS.Code) -> Observable<Bool>, Observable<Bool>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`attend`(withCode `code`: MashUp_iOS.Code) -> Observable<Bool>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`code`)], returnType: Swift.ObjectIdentifier((Observable<Bool>).self)))
  }

  // MARK: Mocked `attendanceMembers`(`platform`: MashUp_iOS.PlatformTeam?)
  public func `attendanceMembers`(`platform`: MashUp_iOS.PlatformTeam?) -> Observable<[MashUp_iOS.AttendanceMember]> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`attendanceMembers`(`platform`: MashUp_iOS.PlatformTeam?) -> Observable<[MashUp_iOS.AttendanceMember]>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`platform`)], returnType: Swift.ObjectIdentifier((Observable<[MashUp_iOS.AttendanceMember]>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (MashUp_iOS.PlatformTeam?) -> Observable<[MashUp_iOS.AttendanceMember]> { return mkbImpl(`platform`) }
      if let mkbImpl = mkbImpl as? () -> Observable<[MashUp_iOS.AttendanceMember]> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Observable<[MashUp_iOS.AttendanceMember]> = mkbObject.`attendanceMembers`(platform: `platform`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Observable<[MashUp_iOS.AttendanceMember]>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `attendanceMembers`(`platform`: @autoclosure () -> MashUp_iOS.PlatformTeam?) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (MashUp_iOS.PlatformTeam?) -> Observable<[MashUp_iOS.AttendanceMember]>, Observable<[MashUp_iOS.AttendanceMember]>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (MashUp_iOS.PlatformTeam?) -> Observable<[MashUp_iOS.AttendanceMember]>, Observable<[MashUp_iOS.AttendanceMember]>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`attendanceMembers`(`platform`: MashUp_iOS.PlatformTeam?) -> Observable<[MashUp_iOS.AttendanceMember]>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`platform`)], returnType: Swift.ObjectIdentifier((Observable<[MashUp_iOS.AttendanceMember]>).self)))
  }
}

/// Returns a concrete mock of `AttendanceService`.
public func mock(_ type: MashUp_iOS.AttendanceService.Protocol, file: StaticString = #file, line: UInt = #line) -> AttendanceServiceMock {
  return AttendanceServiceMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked AuthenticationResponder
public final class AuthenticationResponderMock: MashUp_iOS.AuthenticationResponder, Mockingbird.Mock {
  typealias MockingbirdSupertype = MashUp_iOS.AuthenticationResponder
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "MashUp_iOS"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    AuthenticationResponderMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `loadFailure`()
  public func `loadFailure`() -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`loadFailure`() -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`loadFailure`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `loadFailure`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`loadFailure`() -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked `loadSuccess`(`userSession`: MashUp_iOS.UserSession)
  public func `loadSuccess`(`userSession`: MashUp_iOS.UserSession) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`loadSuccess`(`userSession`: MashUp_iOS.UserSession) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`userSession`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (MashUp_iOS.UserSession) -> Void { return mkbImpl(`userSession`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`loadSuccess`(userSession: `userSession`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `loadSuccess`(`userSession`: @autoclosure () -> MashUp_iOS.UserSession) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (MashUp_iOS.UserSession) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (MashUp_iOS.UserSession) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`loadSuccess`(`userSession`: MashUp_iOS.UserSession) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`userSession`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns a concrete mock of `AuthenticationResponder`.
public func mock(_ type: MashUp_iOS.AuthenticationResponder.Protocol, file: StaticString = #file, line: UInt = #line) -> AuthenticationResponderMock {
  return AuthenticationResponderMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked QRReaderService
public final class QRReaderServiceMock: MashUp_iOS.QRReaderService, Mockingbird.Mock {
  typealias MockingbirdSupertype = MashUp_iOS.QRReaderService
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "MashUp_iOS"])

  // MARK: Mocked captureSession
  public var `captureSession`: AVCaptureSession {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "captureSession.getter", setterSelectorName: "captureSession.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((AVCaptureSession).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> AVCaptureSession { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as AVCaptureSession }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            break
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: AVCaptureSession = mkbObject.`captureSession`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (AVCaptureSession).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getCaptureSession() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AVCaptureSession, AVCaptureSession> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> AVCaptureSession, AVCaptureSession>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "captureSession.getter", setterSelectorName: "captureSession.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((AVCaptureSession).self)))
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    QRReaderServiceMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `scanCodeWhileSessionIsOpen`()
  public func `scanCodeWhileSessionIsOpen`() -> Observable<MashUp_iOS.Code> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`scanCodeWhileSessionIsOpen`() -> Observable<MashUp_iOS.Code>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Observable<MashUp_iOS.Code>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> Observable<MashUp_iOS.Code> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Observable<MashUp_iOS.Code> = mkbObject.`scanCodeWhileSessionIsOpen`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Observable<MashUp_iOS.Code>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `scanCodeWhileSessionIsOpen`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Observable<MashUp_iOS.Code>, Observable<MashUp_iOS.Code>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Observable<MashUp_iOS.Code>, Observable<MashUp_iOS.Code>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`scanCodeWhileSessionIsOpen`() -> Observable<MashUp_iOS.Code>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Observable<MashUp_iOS.Code>).self)))
  }
}

/// Returns a concrete mock of `QRReaderService`.
public func mock(_ type: MashUp_iOS.QRReaderService.Protocol, file: StaticString = #file, line: UInt = #line) -> QRReaderServiceMock {
  return QRReaderServiceMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked UserSessionRepository
public final class UserSessionRepositoryMock: MashUp_iOS.UserSessionRepository, Mockingbird.Mock {
  typealias MockingbirdSupertype = MashUp_iOS.UserSessionRepository
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "MashUp_iOS"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    UserSessionRepositoryMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `signUp`(with `newAccount`: MashUp_iOS.NewAccount)
  public func `signUp`(with `newAccount`: MashUp_iOS.NewAccount) -> Observable<MashUp_iOS.UserSession> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`signUp`(with `newAccount`: MashUp_iOS.NewAccount) -> Observable<MashUp_iOS.UserSession>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`newAccount`)], returnType: Swift.ObjectIdentifier((Observable<MashUp_iOS.UserSession>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (MashUp_iOS.NewAccount) -> Observable<MashUp_iOS.UserSession> { return mkbImpl(`newAccount`) }
      if let mkbImpl = mkbImpl as? () -> Observable<MashUp_iOS.UserSession> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Observable<MashUp_iOS.UserSession> = mkbObject.`signUp`(with: `newAccount`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Observable<MashUp_iOS.UserSession>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `signUp`(with `newAccount`: @autoclosure () -> MashUp_iOS.NewAccount) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (MashUp_iOS.NewAccount) -> Observable<MashUp_iOS.UserSession>, Observable<MashUp_iOS.UserSession>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (MashUp_iOS.NewAccount) -> Observable<MashUp_iOS.UserSession>, Observable<MashUp_iOS.UserSession>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`signUp`(with `newAccount`: MashUp_iOS.NewAccount) -> Observable<MashUp_iOS.UserSession>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`newAccount`)], returnType: Swift.ObjectIdentifier((Observable<MashUp_iOS.UserSession>).self)))
  }

  // MARK: Mocked `signIn`(`id`: String, `password`: String)
  public func `signIn`(`id`: String, `password`: String) -> Observable<MashUp_iOS.UserSession> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`signIn`(`id`: String, `password`: String) -> Observable<MashUp_iOS.UserSession>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`id`), Mockingbird.ArgumentMatcher(`password`)], returnType: Swift.ObjectIdentifier((Observable<MashUp_iOS.UserSession>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (String, String) -> Observable<MashUp_iOS.UserSession> { return mkbImpl(`id`, `password`) }
      if let mkbImpl = mkbImpl as? () -> Observable<MashUp_iOS.UserSession> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Observable<MashUp_iOS.UserSession> = mkbObject.`signIn`(id: `id`, password: `password`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Observable<MashUp_iOS.UserSession>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `signIn`(`id`: @autoclosure () -> String, `password`: @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String, String) -> Observable<MashUp_iOS.UserSession>, Observable<MashUp_iOS.UserSession>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String, String) -> Observable<MashUp_iOS.UserSession>, Observable<MashUp_iOS.UserSession>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`signIn`(`id`: String, `password`: String) -> Observable<MashUp_iOS.UserSession>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`id`), Mockingbird.resolve(`password`)], returnType: Swift.ObjectIdentifier((Observable<MashUp_iOS.UserSession>).self)))
  }

  // MARK: Mocked `load`()
  public func `load`() -> Observable<MashUp_iOS.UserSession?> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`load`() -> Observable<MashUp_iOS.UserSession?>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Observable<MashUp_iOS.UserSession?>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> Observable<MashUp_iOS.UserSession?> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Observable<MashUp_iOS.UserSession?> = mkbObject.`load`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Observable<MashUp_iOS.UserSession?>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `load`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Observable<MashUp_iOS.UserSession?>, Observable<MashUp_iOS.UserSession?>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Observable<MashUp_iOS.UserSession?>, Observable<MashUp_iOS.UserSession?>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`load`() -> Observable<MashUp_iOS.UserSession?>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Observable<MashUp_iOS.UserSession?>).self)))
  }
}

/// Returns a concrete mock of `UserSessionRepository`.
public func mock(_ type: MashUp_iOS.UserSessionRepository.Protocol, file: StaticString = #file, line: UInt = #line) -> UserSessionRepositoryMock {
  return UserSessionRepositoryMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}
